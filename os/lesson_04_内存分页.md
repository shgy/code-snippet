首先,分页必须建立在保护模式的基础上.
进入保护模式需要三步:

1. 加载GDT
2. 打开A20
3. 设置cr0的PE位

开启分页机制只需要两步:

1. 设置页目录地址到cr3
2. 设置cr0的PG位

个人感觉, 设置页目录的核心在于创建页目录及页表. 为了最大化简化分页机制的实现,

1. 页目录只填写1项,
2. 页表只填写256项.
3. 将虚拟地址与实地址一一对应起来.
这样, 理解整个核心功能只需要汇编代码不到100行, 真正用于实现分页机制的代码不到30行.
在bochs中看页表如下:
```
info tab
0x000000100000
0x00000000-0x000fffff -> 0x000000000000-0x0000000fffff
```

问题起源:
早期的计算机, 内存容量十分有限.而在多任务系统中, 总有些进程处于等待状态, 但是内存被占用着. 用粗俗的话说就是: 占着茅坑...
因此, 一种解决的办法是将该进程内存中的数据存储到硬盘上, 从而空出内存空间.
等到该进程运行的时候再从硬盘中将数据加载到内存中. 如何保证进程数据从内存移出和加载到内存空间时能够加载到同一个位置呢?
启用虚拟内存机制, 即内存分页.

Linux设计者把4GB内存的高1GB划分给内核空间程序使用, 0~3GB划分给用户空间程序使用.

物理地址0~896MB的这部分内存被映射到3GB~3GB+896MB的虚拟地址上. 固定映射区.
为什么只映射896MB? 剩下的128MB用来干嘛呢? 保留给vmalloc使用的.
即使是vmalloc, 也没有用满这128MB的内存, 而是保留了一些虚拟地址空间用来检测错误.

进入start_kernel后, 内核首先建立一个最基本的内存管理器: bootmem_allocator








