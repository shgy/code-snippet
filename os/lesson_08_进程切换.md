进程是操作系统的核心之一, 每天使用计算机都是在跟进程打交道, 尽管自己可能没有意识到.

<深入理解Linux内核>第三章 进程切换:
"进程恢复执行前必须装入寄存器的一组数据称为硬件上下文(hardware context), 硬件上下文是进程可执行上下文的一个子集,
因为可执行上下文包含进程执行时需要的所有信息. 在Linux中, 进程硬件上下文的一部分存放在TSS段, 而剩余的部分存放在内核态堆栈中."

这段话可以拿到的核心信息有: TSS段, 内核态堆栈 这两个概念很重要.

内核态堆栈+thread_info一共占用8KB连续的内存空间, 这段内存空间占据两个连续的页框,
并且第一个页框的起始地址是2^^13,即8192的倍数.

进程切换这里, 涉及到了内存的管理. 因此, 先补充一下内存管理的知识.

看了一段内存管理的知识点, 发现理解进程切换, 分页及细致的内存管理知识不是必要的.
由于出发点是为了理解清楚概念和知识点,因此在实现上简单粗暴点也无妨.


首先, 内核是加载到(0x00000000~0x000ffffff),即最开始的1MB空间.
那么, 我们就可以将0x001000000~0x001fffff这之间1MB的空间管理起来.
为了验证我的想法，内存可以直接使用:
简单写了一个demo, 将struct page的地址设置到0x00200000
```
#include "print.h"
#include "init.h"
#include "debug.h"
struct page{
   uint32_t a;
   uint32_t b;
};
void main(void) {
    put_str("I am kernel\n");
    init_all();
    struct page *p;
    p=(void* )0x200000;
    p->a=10;
    p->b=20;
    put_int(p->b);
    put_str("\nover");
   while(1);
}
```

1MB空间一共可发分为256页(这里并没有启用内存分页, 而是模拟内存分页的方式)

在处理进程切换之前, 先按照书上的进度, 实现ASSERT断言.



















