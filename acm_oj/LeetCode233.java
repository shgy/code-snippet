package leetcode;
/* Number of Digit One
 * 分析题目：不大于指定数N的所有非负集合中，1出现的次数。
比如13：
其集合为 ： {0，1，2，3，4，5，6，7，8，9，10，11，12，13}
出现1子集为：{1，10，11，12，13}
所以sum=1+1+2+1+1 = 6   (11中1出现了两次，所以要加2)

最开始想到的是暴力：一一枚举统计；这种方法基本上就是万能药。虽然效率低，但是毕竟是一种方法。阿Q精神！

11中1出现了两次，这一线索非常重要：我想到的是个位和十位需要分别统计。那么简化问题，每次只考虑一位：
如果只考虑个位，能找到什么规律呢？
个位的排列是0 1 2 ... 7 8 9 0 1 2 ... 7 8 9 ...  ： 每10个数中会出现1次1 ， 所以可能是N/10 向上取整，公式(N-1)/10+1应该可以满足，最后修正成 (N+9)/10;  (尽量找到形式简单的公式)

OK，接下来要考虑十位了，其排列为：
0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 ..... 9 9 9 9 9  9 9 9 9 9
即每100个数中，会出现10次1 。不足100的两位数分三种情况：
[00，09]  不会出现1
[10,19] 1的个数不确定，由个位数决定
[20,99] 10个1 拖拖滴！
 
OK，接下来考虑百位了，其排列为
000...(100个0)...000 111...(100个1)...111......999...(100个9)...999
即每1000个数中，会出现100次1，不中1000的三位数分三种情况：
[000,099]  不会出现1
[100,199] 1的个数不确定，由余下两位数决定
[200,999] 100个1 拖拖滴！

其余位依此类推
 * */
public class LeetCode233 {
	public int countDigitOne(int n) {
		long N = (long)n;
        long sum = (n+9)/10;
        long m=10;
        while(N/m!=0){
        	long cur = m*((long)N/(10*m));
        	long rest = N%(10*m);
        	if(rest<m){
        		rest = 0;
        	}else if(rest<2*m){
        		long c = rest%m + 1;
        		cur += c;
        	}else{
        		cur += m;
        	}
        	sum += cur;
        	m = m*10;
        }
        return (int)sum;
    }
	
	public static void main(String[] args) {
		System.out.println(new LeetCode233().countDigitOne(1000));
	}
}
