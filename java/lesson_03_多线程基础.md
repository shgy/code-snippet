故事要从很久以前开始. 在上个世纪60年代, Intel公司的戈登·摩尔预言: 积体电路上可容纳的电晶体（晶体管）数目，约每隔24个月便会增加一倍. 这就是所谓的摩尔定律. 既每18个月, 芯片的性能就会提高一倍.  CPU性能发展如此之快, 但是, 内存和硬盘的读取速度却没有跟上来. 在<性能之巅 : 洞悉系统、企业与云计算>一书中, 对操作耗时进行了一个形象的对比: 假设一个CPU周期是1s, 那么一次内存访问,需要6分钟, 一次固态硬盘访问需要2~6天, 一次机械硬盘访问需要1~12个月,一次物理重启需要32000年.  1秒,32000年!

这种差异导致了CPU在绝大部分时间处于等待状态, 等待数据的到来. 为了更大限度的压榨CPU, 先贤们创造出了进程这以概念. 即多个任务轮流使用CPU.反正就是不让CPU闲着. 

在操作系统中, 进程们各司其职, 但是进程间交流沟通(IPC)的成本却比较高. 以Linux系统为例,无论是管道, FIFO, 消息队列, 还是TCP/IP 都需要经过内核, 本质是消息的传递；共享内存比它们快, 用的是文件映射, 不经内核, 但是需要维护文件描述符,也是重量级的. 而且, 进程创建的开销比较大, 即使有CopyOnWrite这样的优化策略. 

既然能通过mmap共享一部分内存, 为什么不能共享全局内存呢? 既然能共享全局内存, 其他的资源为什么不能共享呢?  这样, 共享进程指令, 全局内存(堆内存), 文件描述符, 工作目录, 信号处理程序, 用户ID和组ID等资源的新事物出现了, 它就是线程. 又称轻量级进程. 线程的出现进一步压榨了硬件, 提升了系统的性能. 

但是线程也引入了更复杂的同步(synchonize)问题. 关于同步, 在其他领域也存在这个问题, 例如"二战期间, 战斗机的同步机枪不会射到螺旋桨的秘密"等. 


前面简单梳理了线程的来源. 到具体的编程语言, 比如Java, 其多线程本质上依然是操作系统的实现, 可以参考`Java线程的创建`. <Thinking In Java> 指明`因为Java所使用的这种并发系统会共享诸如内存和I/O这样的资源, 因此编写多线程程序最基本的困难在于协调不同线程驱动任务之间对这些资源的使用, 以使得这些资源不会同时被多个任务访问` . 所以Java语言层面主要是解决同步问题, 无论是Java内置的synchronized关键字还是1.5开始引入的JUC(java.util.concurrent)包, 其核心功能在于同步. 

在计算机中, 同步问题通常使用`锁`和`CAS原子操作`这两种方式.

对于synchronized关键字, 它是一种悲观锁. <Java虚拟机规范> 2.11.10 中标明Java虚拟机`可以支持方法级的同步和方法内部一段指令序列的同步,这两种同步结构都是使用管程(Monitor)来支持的。`,即synchronized既可修饰方法, 也可以修饰代码块. 修饰方法时, 通过方法常量池中方法表结构的ACC_SYNCHRONIZED访问标志控制同步；修饰代码块时, 使用monitorenter/monitorexit指令对控制. 



参考: 
1. http://www.cnblogs.com/skywang12345/p/java_threads_category.html (Java多线程系列目录(共43篇) )
2. http://blog.csdn.net/jeffhtlee/article/details/12751825 (Java线程的创建 )
3. http://www.cnblogs.com/paddix/p/5367116.html (Java并发编程：Synchronized及其实现原理)
4. https://www.ibm.com/developerworks/cn/java/j-lo-synchronized/ (探索 Java 同步机制)
5. https://www.kancloud.cn/seaboat/java-concurrent/117869 (原文出处：Java并发 作者：汪建)
